=================class 16===================

Blue-Green Deployment
======================
BLUE GREEN deployment is an application release model

It reduces risk and minimizes app downtime

It uses two production environment known as Blue and Green

The Old version can be called the Blue Environment

The new version can be called the green environment

Adv:
Zero Downtime
Rapid releases
Simple rollback

Alternatives to Blue/Green Deployment:

Canary Deployment (Best for Risk Mitigation) 
Canary deployment releases the new version to a small subset of users first (the "canary" group). Traffic is gradually increased to the new version as confidence grows, allowing for real-world testing and early detection of bugs. 

Shadow Deployment	
Routes production traffic copies to a new version without affecting the users' responses. The new version processes requests in the "shadow" but its response is discarded.

A/B Testing	
Similar to Canary, but traffic is routed based on user characteristics (e.g., location, cookies, device) to test different features/UI/workflows.

Recreate	
Shuts down all old Pods before creating any new Pods.

Blue-green deployment strategy practical:
==========================================

vi blue-deployment.yml

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: javawebappbluedeployment
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app: java-web-app
      version: v1
      color: blue
  template:
    metadata:
      labels:
        app: java-web-app
        version: v1
        color: blue
    spec:
      containers:
      - name: javawebappcontainer
        image: hacker123shiva/springbt-in-docker:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
...


vi live-service.yml

---
apiVersion: v1
kind: Service
metadata:
  name: javawebappliveservice
spec:
  type: LoadBalancer
  selector:
    app: java-web-app       # Matches the app
    color: blue            # Sends traffic to the blue pods
  ports:
  - port: 80
    targetPort: 8080

...


vi green-deployment.yml

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: javawebappgreendeployment
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app: java-web-app
      version: v2
      color: green
  template:
    metadata:
      labels:
        app: java-web-app
        version: v2
        color: green
    spec:
      containers:
      - name: javawebappcontainer
        image: hacker123shiva/springbt-in-docker:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
...


vi pre-prod.yml

---
apiVersion: v1
kind: Service
metadata:
  name: javawebpreprodservice
spec:
  type: NodePort
  selector:
    app: java-web-app
    color: green
  ports:
    - port: 80
      targetPort: 8080
      protocol: TCP
      nodePort: 31785  # Optional: remove this if you want auto-assign

...


$ kubectl apply -f blue-deployment.yml

$ kubectl apply -f live-service.yml


$ kubectl apply -f green-deployment.yml

$ kubectl apply -f pre-prod.yml



EFK (Elasticsearch , Fluentd and Kibana)
=========================================
Fluentd collects these (pods) logs, forwards them to Elastic Search for storage and Kibana is used to create dashboard showing logs, error rates, api response time, pod specific issues which will help to trouble shoot and resolve issues.

EFK stack provides centralised logging in order to identify problems with servers or applications. It will help us to reach to search all the logs in a single place

















